//! This module offers structs and traits for valueset analysis as inctroduced
//! in "Analyzing Memory Access in x86 Executables" by Gogul Balakrishnan and
//! Thomas Reps
//! It offers datastructures specific to memory Access
//!
//! There is a little differnce from original paper:
//!     RadecoIL is based on Register SSA, which means every node could symbolize
//!     a register state. Thus, our A_Loc will concentrate on node and memory, 
//!     rather than register.

use std::collections::HashMap;
use std::hash::Hash;
use std::fmt::Debug;
use std::fmt;
use petgraph::graph::NodeIndex;

/// Type of a memory region
#[derive(Hash, Eq, PartialEq, Debug, Clone)]
pub enum MemRegion<T: Debug> {
    /// Global memory region
    Global,
    /// Function-local memory region (each function has its own local memory
    /// region on the stack)
    Local,
    /// Dynamic memory region - allocated at runtime on the heap
    Dynamic {
        callee: T,
    },
}

impl<T: Debug> fmt::Display for MemRegion<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            &MemRegion::Global
                => write!(f, "Global Memory Region"),
            &MemRegion::Local
                => write!(f, "Local Memory Region", ),
            &MemRegion::Dynamic {ref callee}
                => write!(f, "Dynamic Memory Region, generated by OpCall {:?}", callee),
        }
    }
}

#[derive(Hash, Eq, PartialEq, Debug, Clone)]
pub enum AbstractAddress<T: Debug> {
    MemAddr { 
        region: MemRegion<T>, 
        offset: i64,
    },
    Node { 
        node: T,
    },
}

impl<T: Debug> fmt::Display for AbstractAddress<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            &AbstractAddress::MemAddr {ref region, offset}
                => write!(f, "Memory Address: {}, {}", region, offset),
            &AbstractAddress::Node {ref node}
                => write!(f, "SSA-Node"),
        }
    }
}


/// "a-loc" (abstract location)
#[derive(Hash, Eq, PartialEq, Debug, Clone)]
pub struct A_Loc<T: Debug> {
    pub addr: AbstractAddress<T>,
    pub size: Option<u64>,
}

impl<T: Debug> A_Loc<T> {
    fn new_memory(region: MemRegion<T>, offset: i64, size: Option<u64>) -> A_Loc<T> {
        A_Loc {
            addr: AbstractAddress::MemAddr {
                region: region,
                offset: offset,
            },
            size: size,
        }
    }

    fn new_node(node: T, size: Option<u64>) -> A_Loc<T> {
        A_Loc {
            addr: AbstractAddress::Node {
                node: node,
            },
            size: size,
        }       
    }
}

impl<T: Debug> fmt::Display for A_Loc<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.size {
            Some(size)
                => write!(f, "a-loc: {} ({})", self.addr, size),
            None
                => write!(f, "a-loc: {} (unknown size)", self.addr),
        }
    }
}

///// An abstract store
///// This is a map from an a-loc to a value set
//// make generic over architecture
//#[derive(Debug)]
//pub struct AbstractStore<T>
//where T: Hash + Eq + Clone
//{
//    //pub store: HashMap<A_Loc<T>, AbstractValue>,
//    pub store: HashMap<A_Loc<T>, StridedInterval_u>,
//    //// alternatively:
//    //local: HashMap<A_Loc, u64>,
//    //dynamic: HashMap<A_Loc, u64>,
//    //global: HashMap<A_Loc, u64>,
//}
//
//impl<T> AbstractStore<T>
//where T: Hash + Eq + Clone + Debug
//{
//    pub fn new() -> AbstractStore<T> {
//        AbstractStore {
//            store : HashMap::new(),
//            //local : HashMap::new(),
//            //dynamic : HashMap::new(),
//            //global : HashMap::new(), // a-locs -> ValueSet
//        }
//    }
//
//    /// Update the abstract store with an a-loc and a strided interval
//    /// if the a-loc already exists in the abstract store,
//    /// join the strided intervals
//    /// otherwise simply insert a-loc -> strided interval
//    //pub fn update(&mut self, a_loc: A_Loc<T>, strid_interv: AbstractValue) {
//    pub fn update(&mut self, a_loc: A_Loc<T>, strid_interv: StridedInterval_u) {
//        //println!("updating:");
//        //println!("\t{:?}:", a_loc);
//        //println!("\twith: {}", strid_interv);
//        //let strid_interv_up: AbstractValue;
//        let strid_interv_up: StridedInterval_u;
//        if let Some(prev) = self.store.get(&a_loc.clone()) {
//            //println!("\tAlready got entry for this a-loc");
//            //println!("\tprev val: {}", prev);
//            strid_interv_up = prev.join(strid_interv);
//            //println!("\tnow: {}", strid_interv_up);
//        } else {
//            strid_interv_up = strid_interv;
//        }
//        self.store.insert (a_loc.clone(), strid_interv_up);
//    }
//
//    pub fn merge(&mut self, a_store: &mut AbstractStore<T>) {
//        for (a_loc, strid_interv) in a_store.store.drain() {
//            //TODO handle case when aloc already exists in both
//            self.store.insert(a_loc, strid_interv);
//        }
//    }
//}
